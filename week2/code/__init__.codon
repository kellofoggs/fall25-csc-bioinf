# Copyright 2003-2009 by Bartek Wilczynski.  All rights reserved.
# Copyright 2012-2013 by Michiel JL de Hoon.  All rights reserved.
# Revisions copyright 2019 by Victor Lin.  All rights reserved.
# Adapted for use with the codon compiler by Kelly Ojukwu
# This file is part of the Biopython distribution and governed by your
# choice of the "Biopython License Agreement" or the "BSD 3-Clause License".
# Please see the LICENSE file that should have been included as part of this
# package.

# TODO: Make sure to go through all the python imports and make sure that they are being casted after carrying out
# The actions we need the python interpreter to carry out

"""Tools for sequence motif analysis.

Bio.motifs contains the core Motif class containing various I/O methods
as well as methods for motif comparisons and motif searching in sequences.
It also includes functionality for parsing output from the AlignACE, MEME,
and MAST programs, as well as files in the TRANSFAC format.
"""

# Warnings is only ever used in meme.py which already imports warnings, 
# importing package wide is redundant and kind of silly

# Codon doesn't have urllib, it's alright to use python for this as it's a network 
# bound operation
# import python
from python import urllib.parse  as urllib_parse# type: ignore
from python import urllib.request as urllib_request # type: ignore
# from urllib.parse import urlencode
# from urllib.request import Request, urlopen
urlencode = urllib_parse.urlencode
urlopen = urllib_request.urlopen
Request = urllib_request.Request
# from urllib.request import urlopen

import numpy as np # Numpy included in codon distro no need for try catch

from python import Bio.Align as BioAlign # type: ignore
Alignment = BioAlign.Alignment  # type: ignore

from python import Bio.Seq as BioSeq #type: ignore

# from week2.code import matrix
# import week2.code.matrix as matrix
def create(instances, alphabet:str ="ACGT"): # Alphabet by default is lexographic ordering of DNA base pairs
    alignment = Alignment(instances)
    print(alignment)
    return Motif(alignment=alignment, alphabet=alphabet)

def parse(handle, fmt, strict=True):
    """Parse an output file from a motif finding program.

    Currently supported formats (case is ignored):
     - AlignAce:         AlignAce output file format
     - ClusterBuster:    Cluster Buster position frequency matrix format
     - XMS:              XMS matrix format
     - MEME:             MEME output file motif
     - MINIMAL:          MINIMAL MEME output file motif
     - MAST:             MAST output file motif
     - TRANSFAC:         TRANSFAC database file format
     - pfm-four-columns: Generic position-frequency matrix format with four columns. (CIS-BP, HOMER, HOCOMOCO, Neph, Tiffin)
     - pfm-four-rows:    Generic position-frequency matrix format with four row. (ScerTF, YeTFaSCo, hDPI, iDMMPMM, FlyFactorSurvey, Cys2His2 Zinc Finger Proteins PWM Predictor)
     - pfm:              JASPAR-style position-frequency matrix
     - jaspar:           JASPAR-style multiple PFM format
     - sites:            JASPAR-style sites file

    As files in the pfm and sites formats contain only a single motif,
    it is easier to use Bio.motifs.read() instead of Bio.motifs.parse()
    for those.

    For example:

    >>> from Bio import motifs
    >>> with open("motifs/alignace.out") as handle:
    ...     for m in motifs.parse(handle, "AlignAce"):
    ...         print(m.consensus)
    ...
    TCTACGATTGAG
    CTGCACCTAGCTACGAGTGAG
    GTGCCCTAAGCATACTAGGCG
    GCCACTAGCAGAGCAGGGGGC
    CGACTCAGAGGTT
    CCACGCTAAGAGAAGTGCCGGAG
    GCACGTCCCTGAGCA
    GTCCATCGCAAAGCGTGGGGC
    GAGATCAGAGGGCCG
    TGGACGCGGGG
    GACCAGAGCCTCGCATGGGGG
    AGCGCGCGTG
    GCCGGTTGCTGTTCATTAGG
    ACCGACGGCAGCTAAAAGGG
    GACGCCGGGGAT
    CGACTCGCGCTTACAAGG

    If strict is True (default), the parser will raise a ValueError if the
    file contents does not strictly comply with the specified file format.
    """
    fmt = fmt.lower()
    if fmt == "alignace":
        from python import Bio.motifs.alignance as alignace # type: ignore

        return alignace.read(handle)
    elif fmt == "meme":
        from python import Bio.motifs.meme as meme # type: ignore

        return meme.read(handle)
    elif fmt == "minimal":
        from python import Bio.motifs.minminal as minimal # type: ignore

        return minimal.read(handle)
    elif fmt == "clusterbuster":
        from python import Bio.motifs.clusterbuster as clusterbuster # type: ignore

        return clusterbuster.read(handle)
    elif fmt in ("pfm-four-columns", "pfm-four-rows"):
        from python import Bio.motifs.pfm as pfm # type: ignore

        return pfm.read(handle, fmt)
    elif fmt == "xms":
        from python import Bio.motifs.xms as xms # type: ignore

        return xms.read(handle)
    elif fmt == "mast":
        from python import Bio.motifs.mast as mast # type: ignore

        return mast.read(handle)
    elif fmt == "transfac":
        from python import Bio.motifs.transfac as transfac # type: ignore

        return transfac.read(handle, strict)
    elif fmt in ("pfm", "sites", "jaspar"):
        from python import Bio.motifs.jaspar as jaspar # type: ignore

        return jaspar.read(handle, fmt)
    else:
        raise ValueError("Unknown format %s" % fmt)


def read(handle, fmt, strict=True):
    """Read a motif from a handle using the specified file-format.

    This supports the same formats as Bio.motifs.parse(), but
    only for files containing exactly one motif.  For example,
    reading a JASPAR-style pfm file:

    >>> from Bio import motifs
    >>> with open("motifs/SRF.pfm") as handle:
    ...     m = motifs.read(handle, "pfm")
    >>> m.consensus
    Seq('GCCCATATATGG')

    Or a single-motif MEME file,

    >>> from Bio import motifs
    >>> with open("motifs/meme.psp_test.classic.zoops.xml") as handle:
    ...     m = motifs.read(handle, "meme")
    >>> m.consensus
    Seq('GCTTATGTAA')

    If the handle contains no records, or more than one record,
    an exception is raised:

    >>> from Bio import motifs
    >>> with open("motifs/alignace.out") as handle:
    ...     motif = motifs.read(handle, "AlignAce")
    Traceback (most recent call last):
        ...
    ValueError: More than one motif found in handle

    If however you want the first motif from a file containing
    multiple motifs this function would raise an exception (as
    shown in the example above).  Instead use:

    >>> from Bio import motifs
    >>> with open("motifs/alignace.out") as handle:
    ...     record = motifs.parse(handle, "alignace")
    >>> motif = record[0]
    >>> motif.consensus
    Seq('TCTACGATTGAG')

    Use the Bio.motifs.parse(handle, fmt) function if you want
    to read multiple records from the handle.

    If strict is True (default), the parser will raise a ValueError if the
    file contents does not strictly comply with the specified file format.
    """
    fmt = fmt.lower()
    motifs = parse(handle, fmt, strict)
    if len(motifs) == 0:
        raise ValueError("No motifs found in handle")
    if len(motifs) > 1:
        raise ValueError("More than one motif found in handle")
    motif = motifs[0]
    return motif

class Motif:
    def __init__(self, alphabet="ACGT", alignment =None, counts=None): # type: ignore
        '''
        Motif object constructor:
        Alphabet: A  case sensitive string of symbols that are recognized within the motif matrix
        Alignment: 
        '''
        # from week2.code.motifs import matrix
        from week2.code.matrix import GenericPositionMatrix #,FrequencyPositionMatrix 
        self.name = ""
        
        if counts is not None and alignment is not None: # Both specified
            raise Exception(
                ValueError, "Specify either counts or an alignment, don't specify both"
            )
        elif  counts is not None: # Only counts are specified by user
            # self.alignment = None
            self.nucleotide_pos_freqs:GenericPositionMatrix = GenericPositionMatrix(alphabet, counts)
            self.length = self.nucleotide_pos_freqs.length
            pass
        elif alignment is not None: # Only alignment is specified by user, use frequencies to buld the motifs
            # length:int = int.__from_py__(alignment.length)
            length = int(alignment.length) # Cast alignment.length (pyobj) to a codon int
            def convert_py_np_arr_to_codon_np_arr(np_python_arr)->np.ndarray: # In the case that 
                codon_arr = []
                for entry in np_python_arr:
                    codon_arr.append(float(entry))
                # return codon_arr

                return np.array(codon_arr)

            frequencies= {k: convert_py_np_arr_to_codon_np_arr(v) for k, v in alignment.frequencies.items()}
            for symbol in alphabet:
                if symbol not in frequencies:
                    frequencies[symbol] = np.zeros(length, float)
            self.counts = GenericPositionMatrix(alphabet, frequencies)
            self.alignment = alignment
            self.length = length
        else: # Neither are specified
            self.alignment = None
            self.length = None
            self.counts = None
        self.alphabet = alphabet
        self.pseudocounts = None
        self.background = None
        self.mask = None

            
    pass

    '''This would never look this bad in Java, but here's how I adapted property getter/setter methods from the source code without 
    having to delete method references from memory
    Pet peeve: in Python to call the setter method you use self.attribute_name = assigned_value
    The actual setter method can set the value to something other than whats passed in, which is usually not what the = operator
    Does in any other place in the Python programming language.
    '''

    @property
    def mask(self):
        return self.__mask

    @mask.setter
    def mask(self, mask):
        if self.length is None:
            self.__mask = ()
        elif mask is None:
            self.__mask = (1,) * self.length
        elif len(mask) != self.length:
            raise ValueError(
                "The length (%d) of the mask is inconsistent with the length (%d) of the motif"
                % (len(mask), self.length),
            )
        elif isinstance(mask, str):
            self.__mask = []
            for char in mask:
                if char == "*":
                    self.__mask.append(1)
                elif char == " ":
                    self.__mask.append(0)
                else:
                    raise ValueError(
                        "Mask should contain only '*' or ' ' and not a '%s'" % char
                    )
            self.__mask = tuple(self.__mask)
        else:
            self.__mask = tuple(int(bool(c)) for c in mask)

    @property
    def pseudocounts(self):
        return self._pseudocounts

    @pseudocounts.setter
    def pseudocounts(self, value: dict= None):
        self._pseudocounts = {}
        if isinstance(value, dict):
            self._pseudocounts = {letter: value[letter] for letter in self.alphabet}
        else:
            if value is None:
                value = 0.0
            self._pseudocounts = dict.fromkeys(self.alphabet, value)
    @property
    def background(self):
        return self._background

    @background.setter
    def background(self, value):#:dict = None):
        if isinstance(value, dict):
            self._background = {letter: value[letter] for letter in self.alphabet}
        elif value is None:
            self._background = dict.fromkeys(self.alphabet, 1.0)
        else:
            if not self._has_dna_alphabet() and not self._has_rna_alphabet():
                raise ValueError(
                    "Setting the background to a single value only works for DNA and RNA"
                    "motifs (in which case the value is interpreted as the GC content)"
                )
            T_or_U = "T" if self._has_dna_alphabet() else "U"
            self._background["A"] = (1.0 - value) / 2.0
            self._background["C"] = value / 2.0
            self._background["G"] = value / 2.0
            self._background[T_or_U] = (1.0 - value) / 2.0
        total = sum(self._background.values())
        for letter in self.alphabet:
            self._background[letter] /= total

    @property
    def pwm(self):
        """Calculate and return the position weight matrix for this motif."""
        return self.counts.normalize(self._pseudocounts)

    @property
    def pssm(self):
        """Calculate and return the position specific scoring matrix for this motif."""
        return self.pwm.log_odds(self._background)

    @property
    def consensus(self):
        """Return the consensus sequence."""
        return self.counts.consensus

    @property
    def anticonsensus(self):
        """Return the least probable pattern to be generated from this motif."""
        return self.counts.anticonsensus

    @property
    def degenerate_consensus(self):
        """Return the degenerate consensus sequence.

        Following the rules adapted from
        D. R. Cavener: "Comparison of the consensus sequence flanking
        translational start sites in Drosophila and vertebrates."
        Nucleic Acids Research 15(4): 1353-1361. (1987).

        The same rules are used by TRANSFAC.
        """
        return self.counts.degenerate_consensus

    @property
    def relative_entropy(self):
        """Return an array with the relative entropy for each column of the motif."""
        background = self.background
        pseudocounts = self.pseudocounts
        alphabet = self.alphabet
        counts = self.counts
        length = self.length
        values = np.zeros(length)
        if self.alignment is None:
            total = np.array(
                [
                    sum(counts[c][i] + pseudocounts[c] for c in alphabet)
                    for i in range(length)
                ]
            )
            for letter, frequencies in counts.items():
                frequencies = np.array(frequencies) + pseudocounts[letter]
                mask = frequencies > 0
                frequencies = frequencies[mask] / total[mask]
                values[mask] += frequencies * np.log2(frequencies / background[letter])
        else:
            total = np.zeros(length)
            for letter, frequencies in counts.items():
                total += np.array(frequencies) + pseudocounts[letter]
            for letter, frequencies in counts.items():
                frequencies = np.array(frequencies) + pseudocounts[letter]
                mask = frequencies > 0
                frequencies = frequencies[mask] / total[mask]
                values[mask] += frequencies * np.log2(frequencies / background[letter])
        return values

    def _has_dna_alphabet(self) -> bool:
        return sorted(self.alphabet) == ["A", "C", "G", "T"]

    def _has_rna_alphabet(self) -> bool:
        return sorted(self.alphabet) == ["A", "C", "G", "U"]


    def reverse_complement(self):
        """Return the reverse complement of the motif as a new motif."""
        alphabet = self.alphabet
        if not self._has_dna_alphabet() and not self._has_rna_alphabet():
            raise ValueError(
                "Calculating reverse complement only works for DNA and RNA motifs"
            )
        T_or_U = "T" if self._has_dna_alphabet() else "U"
        if self.alignment is not None:
            alignment = self.alignment.reverse_complement()
            if T_or_U == "U":
                alignment.sequences = [s.replace("T", "U") for s in alignment.sequences]
            res = Motif(alphabet=alphabet, alignment=alignment)
        else:  # has counts
            counts = {
                "A": self.counts[T_or_U][::-1],
                "C": self.counts["G"][::-1],
                "G": self.counts["C"][::-1],
                T_or_U: self.counts["A"][::-1],
            }
            res = Motif(alphabet=alphabet, counts=counts)
        res.__mask = self.__mask[::-1]
        res.background = {
            "A": self.background[T_or_U],
            "C": self.background["G"],
            "G": self.background["C"],
            T_or_U: self.background["A"],
        }
        res.pseudocounts = {
            "A": self.pseudocounts[T_or_U],
            "C": self.pseudocounts["G"],
            "G": self.pseudocounts["C"],
            T_or_U: self.pseudocounts["A"],
        }
        return res

    def weblogo(self, fname, fmt="PNG", **kwds):
        """Download and save a weblogo using the Berkeley weblogo service.

        Requires an internet connection.

        The parameters from ``**kwds`` are passed directly to the weblogo server.

        Currently, this method uses WebLogo version 3.3.
        These are the arguments and their default values passed to
        WebLogo 3.3; see their website at http://weblogo.threeplusone.com
        for more information::

            'stack_width' : 'medium',
            'stacks_per_line' : '40',
            'alphabet' : 'alphabet_dna',
            'ignore_lower_case' : True,
            'unit_name' : "bits",
            'first_index' : '1',
            'logo_start' : '1',
            'logo_end': str(self.length),
            'composition' : "comp_auto",
            'percentCG' : '',
            'scale_width' : True,
            'show_errorbars' : True,
            'logo_title' : '',
            'logo_label' : '',
            'show_xaxis': True,
            'xaxis_label': '',
            'show_yaxis': True,
            'yaxis_label': '',
            'yaxis_scale': 'auto',
            'yaxis_tic_interval' : '1.0',
            'show_ends' : True,
            'show_fineprint' : True,
            'color_scheme': 'color_auto',
            'symbols0': '',
            'symbols1': '',
            'symbols2': '',
            'symbols3': '',
            'symbols4': '',
            'color0': '',
            'color1': '',
            'color2': '',
            'color3': '',
            'color4': '',

        """
        if set(self.alphabet) == set("ACDEFGHIKLMNPQRSTVWY"):
            alpha = "alphabet_protein"
        elif set(self.alphabet) == set("ACGU"):
            alpha = "alphabet_rna"
        elif set(self.alphabet) == set("ACGT"):
            alpha = "alphabet_dna"
        else:
            alpha = "auto"

        frequencies = format(self, "transfac")
        url = "https://weblogo.threeplusone.com/create.cgi"
        values = {
            "sequences": frequencies,
            "format": fmt.lower(),
            "stack_width": "medium",
            "stacks_per_line": "40",
            "alphabet": alpha,
            "ignore_lower_case": True,
            "unit_name": "bits",
            "first_index": "1",
            "logo_start": "1",
            "logo_end": str(self.length),
            "composition": "comp_auto",
            "percentCG": "",
            "scale_width": True,
            "show_errorbars": True,
            "logo_title": "",
            "logo_label": "",
            "show_xaxis": True,
            "xaxis_label": "",
            "show_yaxis": True,
            "yaxis_label": "",
            "yaxis_scale": "auto",
            "yaxis_tic_interval": "1.0",
            "show_ends": True,
            "show_fineprint": True,
            "color_scheme": "color_auto",
            "symbols0": "",
            "symbols1": "",
            "symbols2": "",
            "symbols3": "",
            "symbols4": "",
            "color0": "",
            "color1": "",
            "color2": "",
            "color3": "",
            "color4": "",
        }

        values.update({k: "" if v is False else str(v) for k, v in kwds.items()})
        data = str(urlencode(values).encode("utf-8"))
        req = Request(url, data)
        response = urlopen(req)
        with open(fname, "wb") as output_file:
            im = str(response.read().decode('utf-8'))
            output_file.write(im)


    # Python/Codon base object methods that can be overridden for things like to_string, length/size of object
    def __str__(self, masked=False):
        """Return string representation of a motif."""
        text = ""
        if self.alignment is not None:
            text += "\n".join(self.alignment)

        if masked:
            for i in range(self.length):
                if self.__mask[i]:
                    text += "*"
                else:
                    text += " "
            text += "\n"
        return text        

    def __len__(self):
        """Return the length of a motif.

        Please use this method (i.e. invoke len(m)) instead of referring to m.length directly.
        """
        if self.length is None:
            return 0
        else:
            return self.length

    def format(self, format_spec):
        """Return a string representation of the Motif in the given format.

        Currently supported formats:
         - clusterbuster: Cluster Buster position frequency matrix format
         - pfm : JASPAR single Position Frequency Matrix
         - jaspar : JASPAR multiple Position Frequency Matrix
         - transfac : TRANSFAC like files

        """
        return self.__format__(format_spec)


    def __format__(self, format_spec, **kwargs):
        """Return a string representation of the Motif in the given format.

        Currently supported formats:
         - clusterbuster: Cluster Buster position frequency matrix format
         - pfm : JASPAR single Position Frequency Matrix
         - jaspar : JASPAR multiple Position Frequency Matrix
         - transfac : TRANSFAC like files

        """
        if format_spec in ("pfm", "jaspar"):
            from python import Bio.motifs.jaspar as jaspar # type: ignore

            motifs = [self]
            return jaspar.write(motifs, format_spec)
        elif format_spec == "transfac":
            from python import Bio.motifs.transfac as  transfac # type: ignore

            motifs = [self]
            return transfac.write(motifs)
        elif format_spec == "clusterbuster":
            from python import Bio.motifs.clusterbuster as clusterbuster # type: ignore

            motifs = [self]
            return clusterbuster.write(motifs, **kwargs)
        elif not format_spec:
            # Follow python convention and default to using __str__
            return str(self)
        else:
            raise ValueError("Unknown format type %s" % format_spec)


def write(motifs, fmt, **kwargs):
    """Return a string representation of motifs in the given format.

    Currently supported formats (case is ignored):
     - clusterbuster: Cluster Buster position frequency matrix format
     - pfm : JASPAR simple single Position Frequency Matrix
     - jaspar : JASPAR multiple PFM format
     - transfac : TRANSFAC like files

    """
    fmt = fmt.lower()
    if fmt in ("pfm", "jaspar"):
        from python import Bio.motifs.jaspar as jaspar # type: ignore

        return jaspar.write(motifs, fmt)
    elif fmt == "transfac":
        from python import Bio.motifs.transfac as transfac # type: ignore

        return transfac.write(motifs)
    elif fmt == "clusterbuster":
        from python import Bio.motifs.clusterbuster as clusterbuster # type: ignore

        return clusterbuster.write(motifs, **kwargs)
    else:
        raise ValueError("Unknown format type %s" % fmt)


create(BioSeq.Seq("ATATA"),alphabet="ACGT")
