

# class GenericPositionMatrix(dict[str,list]):
#     '''
#     Inheriting from the dictionary class allows for attributes to be accessed by hashing
#     The generic position matrix is meant
#     '''
#     length: int
#     alphabet: str
#     def __init__(self, alphabet:str, values):

#     # def __init__(self, alphabet:str, values:dict[str, list[float]]):
#         '''
#         values:
#         alphabet:The recognized symbols that make up your string
#         '''
#         self.length = -1 # Avoid using Optional 
#         for symbol in alphabet:
#             sequence_len = len(values[symbol])
#             if self.length < 0:
#                 self.length = sequence_len
#             elif self.length != sequence_len:
#                 raise ValueError("Data has inconsistent lengths")
#             self[symbol] = list(map(float, values[symbol]))
#         self.alphabet = alphabet



#     '''
#     Consensus sequence properties
#     Consensus sequence: the most likely sequence (the sequence made of he most common symbols in each position),
#     Anticonsensus sequence: The sequence where each symbol is the least frequent symbol in each position from our sequence matrix
#     Degenerate consensus sequence: The consensus sequence where multiple different symbols may occur 
#     '''
#     @property
#     def consensus(self):
#         """Return the consensus sequence."""
#         sequence = ""
#         for i in range(self.length):
#             maximum = -math.inf
#             for letter in self.alphabet:
#                 count = self[letter][i]
#                 if count > maximum:
#                     maximum = count
#                     sequence_letter = letter
#             sequence += sequence_letter
#         return Seq(sequence)

#     @property
#     def anticonsensus(self):#-> BioSeq:
#         """Return the anticonsensus sequence."""
#         sequence = ""
#         for i in range(self.length):
#             minimum = math.inf
#             for letter in self.alphabet:
#                 count = self[letter][i]
#                 if count < minimum:
#                     minimum = count
#                     sequence_letter = letter
#             sequence += sequence_letter
#         return Seq(sequence)
    
#     @property
#     def degenerate_consensus(self):
#         """Return the degenerate consensus sequence."""
#         # Following the rules adapted from
#         # D. R. Cavener: "Comparison of the consensus sequence flanking
#         # translational start sites in Drosophila and vertebrates."
#         # Nucleic Acids Research 15(4): 1353-1361. (1987).
#         # The same rules are used by TRANSFAC.
#         degenerate_nucleotide = {
#             "A": "A",
#             "C": "C",
#             "G": "G",
#             "T": "T",
#             "U": "U",
#             "AC": "M",
#             "AG": "R",
#             "AT": "W",
#             "AU": "W",
#             "CG": "S",
#             "CT": "Y",
#             "CU": "Y",
#             "GT": "K",
#             "GU": "K",
#             "ACG": "V",
#             "ACT": "H",
#             "ACU": "H",
#             "AGT": "D",
#             "AGU": "D",
#             "CGT": "B",
#             "CGU": "B",
#             "ACGT": "N",
#             "ACGU": "N",
#         }
#         sequence = ""
#         for i in range(self.length):

            
#             '''
#             In the original implementatoin the nested function is used to get the
#             nucleotide count at the ith index, and so is tagged as noqa. This is the
#             perfect place to replace with a lambda or to define a function outside of the loop that
#             also takes in the index. The function defined outside results in the function
#             being loaded less times and is preferred for slight performance improvements.
#             Lambda is better for readability
#             def get(nucleotide):
#                 return self[nucleotide][i]  # noqa: B023
# '''
#             nucleotides = sorted(self, key=lambda nucleotide: self[nucleotide][i], reverse=True)
#             counts = [self[c][i] for c in nucleotides]
#             # Follow the Cavener rules:
#             if counts[0] > sum(counts[1:]) and counts[0] > 2 * counts[1]:
#                 key = nucleotides[0]
#             elif 4 * sum(counts[:2]) > 3 * sum(counts):
#                 key = "".join(sorted(nucleotides[:2]))
#             elif counts[3] == 0:
#                 key = "".join(sorted(nucleotides[:3]))
#             else:
#                 key = "ACGT"
#             nucleotide = degenerate_nucleotide.get(key, key)
#             sequence += nucleotide
#         return Seq(sequence)

#     def calculate_consensus(
#         self, substitution_matrix=None, plurality=None, identity=0, setcase=None
#     ):
#         """Return the consensus sequence (as a string) for the given parameters.

#         This function largely follows the conventions of the EMBOSS `cons` tool.

#         Arguments:
#          - substitution_matrix - the scoring matrix used when comparing
#            sequences. By default, it is None, in which case we simply count the
#            frequency of each letter.
#            Instead of the default value, you can use the substitution matrices
#            available in Bio.Align.substitution_matrices. Common choices are
#            BLOSUM62 (also known as EBLOSUM62) for protein, and NUC.4.4 (also
#            known as EDNAFULL) for nucleotides. NOTE: This has not yet been
#            implemented.
#          - plurality           - threshold value for the number of positive
#            matches, divided by the total count in a column, required to reach
#            consensus. If substitution_matrix is None, then this argument must
#            be None, and is ignored; a ValueError is raised otherwise. If
#            substitution_matrix is not None, then the default value of the
#            plurality is 0.5.
#          - identity            - number of identities, divided by the total
#            count in a column, required to define a consensus value. If the
#            number of identities is less than identity * total count in a column,
#            then the undefined character ('N' for nucleotides and 'X' for amino
#            acid sequences) is used in the consensus sequence. If identity is
#            1.0, then only columns of identical letters contribute to the
#            consensus. Default value is zero.
#          - setcase             - threshold for the positive matches, divided by
#            the total count in a column, above which the consensus is in
#            upper-case and below which the consensus is in lower-case. By
#            default, this is equal to 0.5.
#         """
#         alphabet = self.alphabet
#         if set(alphabet).union("ACGTUN-") == set("ACGTUN-"):
#             undefined = "N"
#         else:
#             undefined = "X"
#         if substitution_matrix is None:
#             if plurality is not None:
#                 raise ValueError(
#                     "plurality must be None if substitution_matrix is None"
#                 )
#             sequence = ""
#             for i in range(self.length):
#                 maximum = 0
#                 total = 0
#                 for letter in alphabet:
#                     count = self[letter][i]
#                     total += count
#                     if count > maximum:
#                         maximum = count
#                         consensus_letter = letter
#                 if maximum < identity * total:
#                     consensus_letter = undefined
#                 else:
#                     if setcase is None:
#                         setcase_threshold = total / 2
#                     else:
#                         setcase_threshold = setcase * total
#                     if maximum <= setcase_threshold:
#                         consensus_letter = consensus_letter.lower()
#                 sequence += consensus_letter
#         else:
#             raise NotImplementedError(
#                 "calculate_consensus currently only supports substitution_matrix=None"
#             )
#         return sequence

#     @property
#     def gc_content(self):
#         """Compute the fraction GC content. This is the percent of strings that are G or C (not XOR)"""
#         alphabet = self.alphabet
#         gc_total = 0.0
#         total = 0.0
#         cg_set = {"C","G"}
#         for i in range(self.length):
#             for letter in alphabet:
#                 if letter in cg_set:
#                     gc_total += self[letter][i]
#                 total += self[letter][i]
#         return gc_total / total

#     def reverse_complement(self):
#         """Compute reverse complement."""
#         values = {}
#         if self.alphabet == "ACGU":
#             values["A"] = self["U"][::-1]
#             values["U"] = self["A"][::-1]
#         else:
#             values["A"] = self["T"][::-1]
#             values["T"] = self["A"][::-1]
#         values["G"] = self["C"][::-1]
#         values["C"] = self["G"][::-1]
#         alphabet = self.alphabet
#         return self.__class__(alphabet, values)


#     '''
#     Magic methods
#     '''

#     def __str__(self)-> str:
#         """Return a string containing nucleotides and counts of the alphabet in the Matrix."""
#         words:list[str] = ["%6d" % i for i in range(self.length)]
#         line:str = "   " + " ".join(words)
#         lines:list[str] = [line]
#         for letter in self.alphabet:
#             words = ["%6.2f" % value for value in self[letter]]
#             line = "%c: " % letter + " ".join(words)
#             lines.append(line)
#         text = "\n".join(lines) + "\n"
#         return text
    
#     def __getitem__(self, key) -> list:
#         """Return the position matrix of index key."""
#         if isinstance(key, tuple):
#             if len(key) == 2:
#                 key1, key2 = key
#                 if isinstance(key1, slice):
#                     start1, stop1, stride1 = key1.indices(len(self.alphabet))
#                     indices1 = range(start1, stop1, stride1)
#                     letters1 = [self.alphabet[i] for i in indices1]
#                     dim1 = 2
#                 elif isinstance(key1, int): # TODO: numbers.Integral allows for types like bool and custom integer types to be included
#                     letter1 = self.alphabet[key1]
#                     dim1 = 1
#                 elif isinstance(key1, tuple):
#                     letters1 = [self.alphabet[i] for i in key1]
#                     dim1 = 2
#                 elif isinstance(key1, str):
#                     if len(key1) == 1:
#                         letter1 = key1
#                         dim1 = 1
#                     else:
#                         raise KeyError(key1)
#                 else:
#                     raise KeyError("Cannot understand key %s" % key1)
#                 if isinstance(key2, slice):
#                     start2, stop2, stride2 = key2.indices(self.length)
#                     indices2 = range(start2, stop2, stride2)
#                     dim2 = 2
#                 elif isinstance(key2, int): # TODO: numbers.Integral allows for types like bool and custom integer types to be included
#                     index2 = key2
#                     dim2 = 1
#                 else:
#                     raise KeyError("Cannot understand key %s" % key2)
#                 if dim1 == 1 and dim2 == 1:
#                     return dict.__getitem__(self, letter1)[index2]
#                 elif dim1 == 1 and dim2 == 2:
#                     values = dict.__getitem__(self, letter1)
#                     return tuple(values[index2] for index2 in indices2)
#                 elif dim1 == 2 and dim2 == 1:
#                     d = {}
#                     for letter1 in letters1:
#                         d[letter1] = dict.__getitem__(self, letter1)[index2]
#                     return d
#                 else:
#                     d = {}
#                     for letter1 in letters1:
#                         values = dict.__getitem__(self, letter1)
#                         d[letter1] = [values[_] for _ in indices2]
#                     if sorted(letters1) == self.alphabet:
#                         return self.__class__(self.alphabet, d)
#                     else:
#                         return d
#             elif len(key) == 1:
#                 key = key[0]
#             else:
#                 raise KeyError("keys should be 1- or 2-dimensional")
#         if isinstance(key, slice):
#             start, stop, stride = key.indices(len(self.alphabet))
#             indices = range(start, stop, stride)
#             letters = [self.alphabet[i] for i in indices]
#             dim = 2
#         elif isinstance(key, int): # TODO: numbers.Integral allows for types like bool and custom integer types to be included
#             letter = self.alphabet[key]
#             dim = 1
#         elif isinstance(key, tuple):
#             letters = [self.alphabet[i] for i in key]
#             dim = 2
#         elif isinstance(key, str):
#             if len(key) == 1:
#                 letter = key
#                 dim = 1
#             else:
#                 raise KeyError(key)
#         else:
#             raise KeyError("Cannot understand key %s" % key)
#         if dim == 1:
#             return dict.__getitem__(self, letter)
#         elif dim == 2:
#             d = {}
#             for letter in letters:
#                 d[letter] = dict.__getitem__(self, letter)
#             return d
#         else:
#             raise RuntimeError("Should not get here")





#     # def resolve_background(self, background: Optional[dict[str, float]]): # type: ignore
#     #     if background is None:
#     #         background = dict.fromkeys(self.alphabet, 1.0)
#     #     else: 
#     #         background = dict(background)
#     #     return background

class FrequencyPositionMatrix(GenericPositionMatrix):
    """Class for the support of frequency calculations on the Position Matrix."""

    def __init__(self, alphabet:str, values:dict[str, list[float]]):
        super().__init__(alphabet, values)    
        
    
    # def normalize(self, pseudocounts=None):
    #     """Create and return a position-weight matrix by normalizing the counts matrix.

    #     If pseudocounts is None (default), no pseudocounts are added
    #     to the counts.

    #     If pseudocounts is a number, it is added to the counts before
    #     calculating the position-weight matrix.

    #     Alternatively, the pseudocounts can be a dictionary with a key
    #     for each letter in the alphabet associated with the motif.
    #     """
    #     counts = {}
    #     if pseudocounts is None:
    #         for letter in self.alphabet:
    #             counts[letter] = [0.0] * self.length
    #     elif isinstance(pseudocounts, dict):
    #         for letter in self.alphabet:
    #             counts[letter] = [float(pseudocounts[letter])] * self.length
    #     else:
    #         for letter in self.alphabet:
    #             counts[letter] = [float(pseudocounts)] * self.length
    #     for i in range(self.length):
    #         for letter in self.alphabet:
    #             counts[letter][i] += self[letter][i]
    #     # Actual normalization is done in the PositionWeightMatrix initializer
    #     return PositionWeightMatrix(self.alphabet, counts)
