import numpy as np
import copy
from python import networkx as nx # Python objects in this class are from networkx, a graph library

@extend
class set:
    def __hash__(self):
        MAX = int.MAX
        MASK = 2 * MAX + 1
        n = len(self)
        h = 1927868237 * (n + 1)
        h &= MASK
        for x in self:
            hx = hash(x)
            h ^= (hx ^ (hx << 16) ^ 89869747)  * 3644798167
            h &= MASK
        h = h * 69069 + 907133923
        h &= MASK
        if h > MAX:
            h -= MASK + 1
        if h == -1:
            h = 590923713
        return h

class Node: # Not calling this tree node it's already in the Tree.codon file, implying that it's a tree node
    _index: int
    _distance: float
    _is_root:bool 
    _parent: Optional[Node]
    _children: list[Node]

    def __init__(self, children=None, distances=None, index=None):
        self._is_root = False
        self._distance = 0
        self._parent = None
        child: Node
        distance:float
        if index is None:
            # Node is intermediate -> has children
            if children is None or distances is None:
                raise TypeError(
                    "Either reference index (for terminal node) or "
                    "child nodes including the distance "
                    "(for intermediate node) must be set"
                )
            for item in children:
                if not isinstance(item, Node):
                    raise TypeError(
                        f"Expected 'Node', but got '{type(item).__name__}'"
                    )
            for item in distances:
                if not isinstance(item, float) and not isinstance(item, int):
                    raise TypeError(
                        f"Expected 'float' or 'int', "
                        f"but got '{type(item).__name__}'"
                    )
            if len(children) == 0:
                raise TreeError(
                    "Intermediate nodes must at least contain one child node"
                )
            if len(children) != len(distances):
                raise ValueError(
                    "The number of children must equal the number of distances"
                )
            for i in range(len(children)):
                for j in range(len(children)):
                    if i != j and children[i] is children[j]:
                        raise TreeError(
                            "Two child nodes cannot be the same object"
                        )
            self._index = -1 # Indicates that this is not a leaf node
            self._children = list(children)
            for child, distance in zip(children, distances):
                child._set_parent(self, distance)
        elif index < 0:
            raise ValueError("Index cannot be negative")
        else:
            # Node is terminal -> has no children
            if children is not None or distances is not None:
                raise TypeError(
                    "Reference index and child nodes are mutually exclusive"
                )
            self._index = index
            self._children = []
    
    def _set_parent(self,  parent:Node, distance:float):
        if self._parent is not None or self._is_root:
            raise TreeError("Node already has a parent")
        self._parent = parent
        self._distance = distance
    
    def copy(self):
        """
        copy()

        Create a deep copy of this :class:`Node`.

        The copy includes this node, its reference index and deep copies
        of its child nodes.
        The parent node and the distance to it is not included.
        """
        if self.is_leaf():
            return Node(index=self._index)
        else:
            distances = [child.distance for child in self._children]
            children_clones = [child.copy() for child in self._children]
            return Node(children_clones, distances)

    @property
    def index(self):
        return None if self._index == -1 else self._index
    
    @property
    def children(self):
        return self._children
    
    @property
    def parent(self):
        return self._parent
    
    @property
    def distance(self):
        return None if self._parent is None else self._distance

    def is_leaf(self):
        """
        is_leaf()
        
        Check if the node is a leaf node.

        Returns
        -------
        is_leaf : bool
            True if the node is a leaf node, false otherwise.
        """
        return False if self._index == -1 else True
    
    def is_root(self):
        """
        is_root()
        
        Check if the node is a root node.

        Returns
        -------
        is_root : bool
            True if the node is a root node, false otherwise.
        """
        return bool(self._is_root)
    
    def as_root(self):
        """
        as_root()
        
        Convert the node into a root node.

        When a root node is used as `child` parameter in the
        construction of a potential parent node, a :class:`TreeError` is
        raised.
        """
        if self._parent is not None:
            raise TreeError("Node has parent, cannot be a root node")
        self._is_root = True
    
    def distance_to(self,  node:Node, topological:bool=False):
        """
        distance_to(node, topological=False)
        
        Get the distance of this node to another node.

        The distance is the sum of all distances from this and the other
        node to the lowest common ancestor.

        Parameters
        ----------
        node : Node
            The second node for distance calculation.
        

        Returns
        -------
        distance : float
            The distance of this node to `node`.
        
        Raises
        ------
        TreeError
            If the nodes have no common ancestor.
        
        Examples
        --------

        >>> leaf1 = Node(index=0)
        >>> leaf2 = Node(index=1)
        >>> leaf3 = Node(index=2)
        >>> inter = Node([leaf1, leaf2], [5.0, 7.0])
        >>> root  = Node([inter, leaf3], [3.0, 10.0])
        >>> print(leaf1.distance_to(leaf2))
        12.0
        >>> print(leaf1.distance_to(leaf3))
        18.0
        """
        # Sum distances until LCA has been reached
        distance:float = 0
        # current_node:Optional[Node] = None
        lca:Optional[Node] = self.lowest_common_ancestor(node)
        if lca is None:
            raise TreeError("The nodes do not have a common ancestor")
        current_node:Node = self
        while current_node is not lca:
            if topological:
                distance += 1
            else:
                distance += current_node._distance
            current_node = current_node._parent
        current_node = node
        while current_node is not lca:

            if topological:
                distance += 1
            else:
                distance += current_node._distance
            current_node = current_node._parent
        return distance
    
    def lowest_common_ancestor(self,  node:Node):
        """
        lowest_common_ancestor(node)
        
        Get the lowest common ancestor of this node and another node.

        Parameters
        ----------
        node : Node
            The node to get the lowest common ancestor with.

        Returns
        -------
        ancestor : Node or None
            The lowest common ancestor. `None` if the nodes have no
            common ancestor, i.e. they are not in the same tree
        """
        i: int
        lca = None
        # Create two paths from the leaves to root
        self_path:list[Node] = _create_path_to_root(self)
        other_path:list[Node] = _create_path_to_root(node)
        # Reverse Iteration through path (beginning from root)
        # until the paths diverge
        for i in range(-1, -min(len(self_path), len(other_path))-1, -1):
            if self_path[i] is other_path[i]:
                # Same node -> common ancestor
                lca = self_path[i]
            else:
                # Different node -> Not common ancestor
                # -> return last common ancewstor found
                break
        return lca
    
    def get_indices(self):
        """
        get_indices()
        
        Get an array of reference indices that leaf nodes of this node
        contain.

        This method identifies all leaf nodes, which have this node as
        ancestor and puts the contained indices into an array.
        If this node is a leaf node itself, the array contains the
        reference index of this node as single element.

        Returns
        -------
        indices : ndarray, dtype=int32
            The reference indices of direct and indirect child leaf
            nodes of this node.

        Examples
        --------

        >>> leaf0 = Node(index=0)
        >>> leaf1 = Node(index=1)
        >>> leaf2 = Node(index=2)
        >>> leaf3 = Node(index=3)
        >>> intr0 = Node([leaf0, leaf2], [0, 0])
        >>> intr1 = Node([leaf1, leaf3], [0, 0])
        >>> root  = Node([intr0, intr1], [0, 0])
        >>> print(leaf0.get_indices())
        [0]
        >>> print(intr0.get_indices())
        [0 2]
        >>> print(intr1.get_indices())
        [1 3]
        >>> print(root.get_indices())
        [0 2 1 3]
        """
        leaf:Node
        return np.array(
            [leaf._index for leaf in self.get_leaves()], dtype=np.int32
        )

    def get_leaves(self):
        """
        get_leaves()
        
        Get a list of leaf nodes that are direct or indirect child nodes
        of this node.

        This method identifies all leaf nodes, which have this node as
        ancestor.
        If this node is a leaf node itself, the list contains this node
        as single element.

        Returns
        -------
        leaf_nodes : list
            The leaf nodes, that are direct or indirect child nodes
            of this node.
        """
        leaf_list:list[Node] = []
        # delegate to 'cdef' method
        # to reduce overhead of recursive function calling
        _get_leaves(self, leaf_list)
        return leaf_list
    
    def get_leaf_count(self):
        """"
        get_leaf_count()

        Get the number of direct or indirect leaves of this node.

        This method identifies all leaf nodes, which have this node as
        ancestor.
        If this node is a leaf node itself, 1 is returned.
        """
        return _get_leaf_count(self)
    
    def to_newick(self, labels=None, include_distance:bool=True, 
                  round_distance:Optional[int]=None):
        """
        to_newick(labels=None, include_distance=True)
        
        Obtain the node represented in Newick notation.

        The terminal semicolon is not included.

        Parameters
        ----------
        labels : iterable object of str
            The labels the indices in the leaf nodes refer to
        include_distance : bool
            If true, the distances are displayed in the newick notation,
            otherwise they are omitted.
        round_distance : int, optional
            If set, the distances are rounded to the given number of
            digits.
        
        Returns
        -------
        newick : str
            The Newick notation of the node.

        Examples
        --------
        
        >>> leaf1 = Node(index=0)
        >>> leaf2 = Node(index=1)
        >>> leaf3 = Node(index=2)
        >>> inter = Node([leaf1, leaf2], [5.0, 7.0])
        >>> root  = Node([inter, leaf3], [3.0, 10.0])
        >>> print(root.to_newick())
        ((0:5.0,1:7.0):3.0,2:10.0):0.0
        >>> print(root.to_newick(include_distance=False))
        ((0,1),2)
        >>> labels = ["foo", "bar", "foobar"]
        >>> print(root.to_newick(labels=labels, include_distance=False))
        ((foo,bar),foobar)
        """
        if self.is_leaf():
            if labels is not None:
                for label in labels:
                    label = labels[self._index]
                    # Characters that are part of the Newick syntax
                    # are illegal
                    illegal_chars = [",",":",";","(",")"]
                    for char in illegal_chars:
                        if char in label:
                            raise ValueError(
                                f"Label '{label}' contains "
                                f"illegal character '{char}'"
                            )
            else:
                label = str(self._index)
            if include_distance:
                if round_distance is None:
                    return f"{label}:{self._distance}"
                else:
                    out_put_dist = round(self._distance, round_distance)
                    return f"{label}:{out_put_dist}"
            else:
                return f"{label}"
        else:
            # Build string in a recursive way
            child_strings = [child.to_newick(
                labels, include_distance, round_distance
            ) for child in self._children]
            if include_distance:
                if round_distance is None:
                    return f"({','.join(child_strings)}):{self._distance}"
                else:
                    out_put_dist = round(self._distance, round_distance)

                    return (
                        
                        f"({','.join(child_strings)}):"
                        f"{out_put_dist}"
                    )
            else:
                return f"({','.join(child_strings)})"
    
    @staticmethod
    def from_newick( newick:str, labels_list:Optional[list]=None):
        """
        from_newick(newick, labels=None)

        Create a node and all its child nodes from a Newick notation.

        Parameters
        ----------
        newick : str
            The Newick notation to create the node from.
        labels : list of str, optional
            If the Newick notation contains labels, that are not
            parseable into reference indices,
            i.e. they are not integers, this parameter can be provided
            to convert these labels into reference indices.
            The corresponding index is the position of the label in the
            provided list.

        Returns
        -------
        node : Node
            The tree node parsed from the Newick notation.
        distance : float
            Distance of the node to its parent. If the newick notation
            does not provide a distance, it is set to 0 by default.
        
        Notes
        -----
        The provided Newick notation must not have a terminal semicolon.
        If you have a Newick notation that covers an entire tree, you
        may use the same method in the :class:`Tree` class instead.
        Keep in mind that the :class:`Node` class does support any
        labels on intermediate nodes.
        If the string contains such labels, they are discarded.
        """
        i:int
        subnewick_start_i:int = -1
        subnewick_stop_i:int  = -1
        level:int = 0
        comma_pos:list
        children:list
        distances:list
        pos:int
        next_pos:int
        
        # Ignore any whitespace
        newick = "".join(newick.split())

        # Find brackets belonging to sub-newick
        # e.g. (A:0.1,B:0.2):0.5
        #      ^           ^
        for i in range(len(newick)):
            char = newick[i]
            if char == "(":
                subnewick_start_i = i
                break
            if char == ")":
                raise IOError("Bracket closed before it was opened")
        for i in reversed(range(len(newick))):
            char = newick[i]
            if char == ")":
                subnewick_stop_i = i+1
                break
            if char == "(":
                raise IOError("Bracket was opened but not closed")
        
        if subnewick_start_i == -1 and subnewick_stop_i == -1:
            # No brackets -> no sub-newwick -> Leaf node
            label_and_distance = newick
            try:
                label, distance_str = label_and_distance.split(":")
                distance = float(distance_str)
            except ValueError:
                # No colon -> No distance is provided
                distance = 0
                label = label_and_distance
            finally:
                index: int
                if labels_list is None and label is not None:
                    index = int(label)
                else:
                    if label is not None :
                        found_element = 0
                        for i in range(0, len(label)):
                            element = labels_list[i]
                            if element is not None and element == label:
                                index = i
                                found_element = 1
                                break
                    if found_element == 0:
                        raise IOError("The label could not be found")
                    # index = labels_list.index(label)
                # index = int(label) if labels_list is None else labels_list.index(label) # If  is 
                return Node(index=index), distance
        
        else:
            # Intermediate node
            if subnewick_stop_i == len(newick):
                # Node with neither distance nor label
                label = None
                distance = 0
            else:
                label_and_distance = newick[subnewick_stop_i:]
                try:
                    label, distance_str = label_and_distance.split(":")
                    distance = float(distance_str)
                except ValueError:
                    # No colon -> No distance is provided
                    distance = 0
                    label = label_and_distance
                # Label of intermediate nodes is discarded 
                distance = float(distance)
            
            subnewick = newick[subnewick_start_i+1 : subnewick_stop_i-1]
            if len(subnewick) == 0:
                raise IOError(
                    "Intermediate node must at least have one child"
                )
            # Parse childs
            # Split subnewick at ',' if ',' is at current level
            # (not in a subsubnewick)
            comma_pos = []
            for i, char in enumerate(subnewick):
                if char == "(":
                    level += 1
                elif char == ")":
                    level -= 1
                elif char == ",":
                    if level == 0:
                        comma_pos.append(i)
                if level < 0:
                    raise IOError(
                        "Bracket closed before it was opened"
                    )
        
            children = []
            distances = []
            # Recursive tree construction
            for i, pos in enumerate(comma_pos):
                if i == 0:
                    # (A,B),(C,D),(E,F)
                    # -----
                    child, dist = Node.from_newick(
                        subnewick[:pos], labels_list=labels_list
                    )
                else:
                    # (A,B),(C,D),(E,F)
                    #       -----
                    prev_pos = comma_pos[i-1]
                    child, dist = Node.from_newick(
                        subnewick[prev_pos+1 : pos], labels_list=labels_list
                    )
                children.append(child)
                distances.append(dist)
            # Node after last comma
            # (A,B),(C,D),(E,F)
            #             -----
            if len(comma_pos) != 0:
                child, dist = Node.from_newick(
                    subnewick[comma_pos[-1]+1:], labels_list=labels_list
                )
            else:
                # Single child node:
                child, dist = Node.from_newick(
                    subnewick, labels_list=labels_list
                )
            children.append(child)
            distances.append(dist)
            return Node(children, distances), distance

    def __str__(self):
        return self.to_newick()
    
    def __eq__(self, item):
        if not isinstance(item, Node):
            return False
        node:Node = item
        if self._distance != node._distance:
            return False
        if self._index !=-1:
            if self._index != node._index:
                return False
        else:
            if set(self._children) != set(node._children):
                return False
        return True
    
    def __ne__(self, value):
        return not self.__eq__(value)
    
    def __hash__(self):
        # Order of children is not important -> set
        children_set = set(self._children) \
                       if self._children is not None else None
        return hash((self._index, children_set, self._distance))

class Tree: # A tree should be deep copyable. TODO: In Java, a Tree Node would most likely  be nested inside of this class. 

    _root: Node
    _leaves: list[Optional[Node]]

    

    def __init__(self, root: Node): 
        root.as_root()  # Ensure the "root" node is set as root
        self._root = root

        leaves_list = self.root.get_leaves()
        leaf_count = len(leaves_list)
        indices: np.ndarray = np.array([leaf.index for leaf in leaves_list])
        temp_leaves = [None] * leaf_count
        for i in range(len(indices)):
            _index = indices[i]
            if _index >= leaf_count or _index < 0:
                raise ValueError("The trees indices are out of range")
            temp_leaves[_index] = leaves_list[i] # This line right here caused me a lot of trouble :(
        self._leaves = temp_leaves
    
    
    @property
    def root(self) -> Node: 
        return self._root
    @property
    def leaves(self):
        return copy.copy(self._leaves)

    @root.setter
    def root(self, value):
        if isinstance(value, Node):
            self._root = value
        # else:
        #     raise(TypeError("The root must be set to a Node and can not be none"))
    
    def to_newick(self, labels:Optional[list[str]]=None, include_distance:bool = True, round_distance:Optional[int]=None):
        return self._root.to_newick(labels, include_distance, round_distance) +";"
        pass

    @staticmethod
    def from_newick(newick_string: str, labels_list:Optional[list]=None):
    
        newick_string = newick_string.strip()
        if len(newick_string) <= 0:
            raise ValueError("Newick string is empty")
        elif newick_string[-1] == ";": # Strip the trailing semicolon from the newick_string
            newick_string = newick_string[:-1]
        root, distance = Node.from_newick(newick_string, labels_list)
        return Tree(root)
    
    def __copy_create__(self):
        return Tree(self._root.copy())


    def as_graph(self):
        """
        as_graph()
        
        Obtain a graph representation of the :class:`Tree`.

        Returns
        -------
        bond_set : DiGraph
            A *NetworkX* directed graph.
            For a leaf node the graph node is its reference index.
            For an intermediate and root node the graph node is a list
            containing it children nodes.
            Each edge has a ``"distance"`` attribute depicting the
            distance between the nodes.
            Each edge starts from the parent ends at its child.
        
        Examples
        --------

        >>> leaves = [Node(index=i) for i in range(3)]
        >>> intermediate = Node([leaves[0], leaves[1]], [2.0, 3.0])
        >>> root = Node([intermediate, leaves[2]], [1.0, 5.0])
        >>> tree = Tree(root)
        >>> graph = tree.as_graph()
        >>> for node_i, node_j in graph.edges:
        ...     print(f"{str(node_i):12}  ->  {str(node_j):12}")
        (0, 1)        ->  0
        (0, 1)        ->  1
        ((0, 1), 2)   ->  (0, 1)
        ((0, 1), 2)   ->  2
        """
        children:list #tuple
        # children:tuple
        children_already_handled:int # This is literally never used
        node:Node
        child: Node
        parent: Node

        graph:pyobj = nx.DiGraph() # PyObject
        
        # This dict maps a Node to its corresponding int or tuple
        node_repr: dict[Node, int|list] = {}

        # A First-In-First-Out queue for iterative handling of each node
        # Starting with all leaf nodes 
        queue:list = copy.copy(self._leaves)
        # A set representation of the same queue for efficient
        # '__contains__()' operation
        queue_set = set(self._leaves)
        while len(queue) > 0:
            node = queue.pop(0)
            
            if node.is_leaf():
                node_repr[node] = node.index
            else:
                children = node.children
                children_handled = True
                for child in children:
                    if child not in node_repr:
                        children_handled = False
                # If the node representation of any child of this node
                # is not calculated yet, put this node to the end of the
                # queue and handle it later
                if not children_handled:
                    queue.append(node)
                    continue
                else:
                    repr = [node_repr[child] for child in children]
                    node_repr[node] = repr
                    # Add adges to children in graph
                    for child in children:
                        graph.add_edge(
                            repr, node_repr[child], distance=child.distance
                        ) # Cast to python objects
            
            # This leads finally to termination of the loop:
            # When the root node is handled the last element in the
            # queue is handled and no new node is added to the queue
            if not node.is_root():
                parent = node.parent
                # The parent node might be already in the queue from
                # handling another child node
                if parent not in queue_set:
                    queue.append(parent)
                    queue_set.add(parent)
            
            # Node is handled
            # -> not in 'queue' anymore
            # -> remove also from 'queue_set'
            queue_set.remove(node)
        
        return graph
    
    def get_distance(self, index1:int, index2:int, topological:bool=False)->float:
        """
        get_distance(index1, index2, topological=False)
        
        Get the distance between two leaf nodes.

        The distance is the sum of all distances from the each of the
        two nodes to their lowest common ancestor.

        Parameters
        ----------
        index1, index2 : int
            The reference indices of the two leaf nodes, to calculate
            the distance for.
        topological : bool, optional
            If True the topological distance is measured, i.e. all
            child-parent distance is 1.
            Otherwise, the distances from the `distance` attribute are
            used.

        Returns
        -------
        distance : float
            The distance between the nodes.
        
        Examples
        --------

        >>> leaf1 = Node(index=0)
        >>> leaf2 = Node(index=1)
        >>> leaf3 = Node(index=2)
        >>> inter = Node([leaf1, leaf2], [5.0, 7.0])
        >>> root  = Node([inter, leaf3], [3.0, 10.0])
        >>> tree = Tree(root)
        >>> print(tree.get_distance(0,1))
        12.0
        >>> print(tree.get_distance(0,2))
        18.0
        >>> print(tree.get_distance(1,2))
        20.0
        """
        return self._leaves[index1].distance_to(
            self._leaves[index2], topological
        )

    
    
    def __str__(self):
        return self.to_newick()
    
    def __len__(self):
        return len(self._leaves)
    
    def __eq__(self, other_item):
        if  isinstance(other_item, Tree):
            return self._root == other_item._root
        else:
            return False

        pass
    
    def __ne__(self, other_item):
        return not self.__eq__(other_item)

    def __hash__(self):
        return hash(self._root)

 




def _get_leaves(node: Node, leaf_list:list[Node])-> list[Node]:
    child: Node
    if node._index == -1:
        # Intermediate node -> Recursive calls
        for child in node._children:
            _get_leaves(child, leaf_list)
    else:
        # Node itself is leaf node -> add node -> terminate
        leaf_list.append(node)


def _get_leaf_count(node: Node) -> int:
    # child: Node
    count:int = 0
    if node._index == -1:
        # Intermediate node -> Recursive calls
        for child in node._children:
            count += _get_leaf_count(child)
        return count
    else:
        # Leaf node -> return count of itself = 1
        return 1


def _create_path_to_root(node:Node)->list[Node]:
    """
    Create a list of nodes representing the path from this node to the
    specified node
    """
    path:list[Node] = []
    current_node:Optional[Node] = node
    while current_node is not None:
        path.append(current_node)
        current_node = current_node._parent
    return path



def as_binary(tree_or_node) : # TODO: EXPLICIT RETURN TYPE!
    """
    as_binary(tree_or_node)

    Convert a tree into a binary tree.

    In general a :class:`Node` can have more or less than two
    children.
    However guide trees usually expect each intermediate node to have
    exactly two child nodes.
    This function creates a binary :class:`Tree` (or :class:`Node`)
    for the given :class:`Tree` (or :class:`Node`):
    Intermediate nodes that have only a single child are deleted and its
    parent node is directly connected to its child node.
    Intermediate nodes that have more than two childs are divided into
    multiple nodes (distances are preserved).
    
    Parameters
    ----------
    tree_or_node : Tree or Node
        The tree or node to be converted into a binary tree or node.
    
    Returns
    -------
    binary_tree_or_node : Tree or Node
        The converted tree or node.
    """
    if isinstance(tree_or_node, Tree):
        node, _ = _as_binary(tree_or_node.root)
        return Tree(node)
    elif isinstance(tree_or_node, Node):
        node, _ = _as_binary(tree_or_node)
        return _as_binary(node)
    else:
        raise TypeError(
            f"Expected 'Tree' or 'Node', not {type(tree_or_node).__name__}"
        )

def _as_binary(node: Node):
    """
    The actual logic wrapped by :func:`as_binary()`.
    
    Parameters
    ----------
    node : Node
        The node to be converted.
    
    Returns
    -------
    binary_node: Node
        The converted node.
    distance : float
        The distance of the converted node to its parent
    """
    child: Node
    current_div_node: Node
    children: tuple
    rem_children: list
    distances: list
    distance: float

    children = node.children
    if children is None:
        # Leaf node
        return Node(index=node.index), node.distance
    elif len(children) == 1:
        # Intermediate node with one child
        # -> Omit node and directly connect its child to its parent
        # The distances are added
        #
        #      |--            |--   
        #      |              |   
        # --|--|--   ->   ----|--  
        #      |              |   
        #      |--            |-- 
        #
        child, distance = _as_binary(node.children[0])
        if node.is_root():
            # Child is new root -> No distance to parent
            return child, None
        else:
            return child, node.distance + distance
    elif len(children) > 2:
        # Intermediate node with more than two childs
        # -> Create a new node having two childs:
        #    - One of the childs of the original node
        #    - The original node with one child less (distance = 0)
        # Repeat until all children are put into binary nodes
        #
        #   |--          |--
        #   |          --|  |--
        # --|--   ->     |--|
        #   |               |--
        #   |--
        #
        # The remaining children
        rem_children, distances = [list(tup) for tup in zip(
            *[_as_binary(child) for child in children]
        )]
        current_div_node = None
        while len(rem_children) > 0:
            if current_div_node is None:
                # The bottom-most node is created
                #-> Gets two of the remaining childs
                current_div_node = Node(
                    rem_children[:2],
                    distances[:2]
                )
                # Pop the two utilized remaining childs from the list
                rem_children.pop(0)
                rem_children.pop(0)
                distances.pop(0)
                distances.pop(0)
            else:
                # A node is created that gets one remaining child
                # and the intermediate node from the last step
                current_div_node = Node(
                    (current_div_node, rem_children[0]),
                    (0, distances[0]) 
                )
                # Pop the utilized remaining child from the list
                rem_children.pop(0)
                distances.pop(0)
        return current_div_node, node.distance
    else:
        # Intermediate node with exactly two childs
        # -> Keep node unchanged
        binary_children, distances = [list(tup) for tup in zip(
            *[_as_binary(child) for child in children]
        )]
        return Node(binary_children, distances), node.distance


class TreeError(Static[Exception]):
    def __init__(self):
        super().__init__('TreeError')
    pass